<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Gonzazoid's blog - <span>&tau;-lang: usage</span></title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Gonzazoid's blog</a>
            </div>
            <nav>
                <a href="../">Index</a>
                <a href="../resume_ru.html">[ Resume: RU</a>
                <a href="../resume.html">ENG ]</a>
                <a href="../contact.html">Contact</a>
            </nav>
        </header>

        <main role="main">
            <h1><span>&tau;-lang: usage</span></h1>
            <article>
    <section class="header">
        Posted on January 10, 2020
        
    </section>
    <section>
        <blockquote>
I’m gonna show you as gently as I can how much you don’t know.
<footer>
— Dennis “Cutty” Wise (Chad L. Coleman), <cite>The Wire, Season 4: Refugees</cite>
</footer>
</blockquote>
<h3 id="практика-применения.">Практика применения.</h3>
<h4 id="let-it-be">Let it be</h4>
<p>Первое (наверно) что бросается в глаза программисту пришедшему с императивных языков - это отсутствие присваивания в τ-lang. На самом деле присваивание конечно есть, но оно спрятано в двух местах - вызов функции (apply) и сопоставление по образцу (pattern-matching). Тем кто пришел с функциональных языков будет полегче, кто знаком с λ-calculus - совсем привычно. Давайте последовательно разберем.</p>
<p>Возмем простую функцию NOT - если она получает на входе true - возращает false, если false - возвращает true. Вот она:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb1-1" title="1">(a =&gt; <span class="kw">match</span> a</a>
<a class="sourceLine" id="cb1-2" title="2">  | <span class="kw">true</span> =&gt; <span class="kw">false</span></a>
<a class="sourceLine" id="cb1-3" title="3">  | <span class="kw">false</span> =&gt; <span class="kw">true</span></a>
<a class="sourceLine" id="cb1-4" title="4">)</a></code></pre></div>
<p>Но как нам теперь назвать ее not что бы использовать в дальнейшем в коде? Для того что бы привязать значение к имени - это значение должно быть в вызове функции (apply), вот так:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb2-1" title="1">(</a>
<a class="sourceLine" id="cb2-2" title="2">  (someName =&gt; </a>
<a class="sourceLine" id="cb2-3" title="3">    тело функции</a>
<a class="sourceLine" id="cb2-4" title="4">  )</a>
<a class="sourceLine" id="cb2-5" title="5">  someValue</a>
<a class="sourceLine" id="cb2-6" title="6">)</a></code></pre></div>
<p>В этом примере в теле функции будет доступна константа с именем someName и значением someValue. Вот более конкретный пример с функцией not:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb3-1" title="1">(<span class="dt">not</span> ... =&gt; какой то код которому теперь доступна функция <span class="dt">not</span>)</a>
<a class="sourceLine" id="cb3-2" title="2">(a =&gt; <span class="kw">match</span> a</a>
<a class="sourceLine" id="cb3-3" title="3">  | <span class="kw">true</span> =&gt; <span class="kw">false</span></a>
<a class="sourceLine" id="cb3-4" title="4">  | <span class="kw">false</span> =&gt; <span class="kw">true</span></a>
<a class="sourceLine" id="cb3-5" title="5">)</a></code></pre></div>
<p>Первая строка - это объявление функии у которой первый параметр имеет имя not. Вторая и далее строки - это объявление первого параметра apply. При вызове этой функии значение (в данном случае объявление функции not) будет привязано к имени параметра (not)</p>
<p>Другая возможность привязать значение к имени - это pattern matching или деструктуризация. Предположим у нас есть некоторая структура, например:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb4-1" title="1">(STATE (L (REG ax (S (S O))) (L (REG bx O) EMPTY)) CACHE MEM)</a></code></pre></div>
<p>и эта структура передается вот этой функции:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb5-1" title="1">(state eval =&gt; <span class="kw">match</span> state</a>
<a class="sourceLine" id="cb5-2" title="2">  | STATE regs cache mem =&gt; ... body ...</a>
<a class="sourceLine" id="cb5-3" title="3">)</a>
<a class="sourceLine" id="cb5-4" title="4">(STATE (L (REG ax (S (S O))) (L (REG bx O) EMPTY)) CACHE MEM)</a></code></pre></div>
<p>match делает деструктуризацию state и сравнивает клоз на совпадение конструктора и числа аргументов. Поскольку совпадение есть, происходит присваивание, такое что в том месте где у нас расположен … body … нам доступны константы:</p>
<ul>
<li>regs со значением <code>(L (REG ax (S (S O))) (L (REG bx O) EMPTY))</code></li>
<li>cache значением которого будет символ CACHE (constructor ground term)</li>
<li>mem значением которого будет символ MEM (constructor ground term)</li>
</ul>
В принципе думаю этого достаточно что бы понять как связывать в τ-lang значение с именем.
<hr>
<h4 id="recursion">Recursion</h4>
<p>Как вы помните, в τ-lang нет рекурсивных функций, есть рекурсивные вызовы. Если вы знакомы с Y-комбинатором из λ-calculus то понять дальнейшее не составит труда.</p>
<p>Вот пример <code>apply</code> функции складывающей два натуральных числа:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb6-1" title="1">(sum a b =&gt; </a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="kw">match</span> a</a>
<a class="sourceLine" id="cb6-3" title="3">        | O =&gt; b</a>
<a class="sourceLine" id="cb6-4" title="4">        | S a' =&gt; S (sum sum a' b)</a>
<a class="sourceLine" id="cb6-5" title="5">)</a>
<a class="sourceLine" id="cb6-6" title="6">(sum a b =&gt; </a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="kw">match</span> a</a>
<a class="sourceLine" id="cb6-8" title="8">        | O =&gt; b</a>
<a class="sourceLine" id="cb6-9" title="9">        | S a' =&gt; S (sum sum a' b)</a>
<a class="sourceLine" id="cb6-10" title="10">)</a>
<a class="sourceLine" id="cb6-11" title="11">(S(S O))</a>
<a class="sourceLine" id="cb6-12" title="12">(S(S(S O)))</a></code></pre></div>
<p>Обратите внимание на первое объявление функции:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb7-1" title="1">(sum a b =&gt; </a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="kw">match</span> a</a>
<a class="sourceLine" id="cb7-3" title="3">        | O =&gt; b</a>
<a class="sourceLine" id="cb7-4" title="4">        | S a' =&gt; S (sum sum a' b)</a>
<a class="sourceLine" id="cb7-5" title="5">)</a></code></pre></div>
<p>sum - это не имя этой функции, sum - это имя первого параметра этой функции. И если мы передадим этой функции первым параметром ее саму же (или точнее объявление такой же функции) - то вызов станет рекурсивным. Но мы можем передать в параметре sum другую функцию, например (sum a b =&gt; a) и вызов в этом случае становится нерекурсивным.</p>
<p>Но вернемся к рекурсивному вызову. Итак нам надо передать в параметре sum такую же функцию. Поэтому мы дублируем ее и передаем первым параметром в apply.</p>
<p>А теперь обратите внимание как происходит вызов в теле функции: <code>sum sum a' b</code> - мы точно так же вызываем sum и передаем ее же первым параметром. Именно поэтому и первый и все последующие (вложенные или порожденные) вызовы будут рекурсивными.</p>
<p>Результат вызова: <code>(S(S(S(S(S O)))))</code></p>
<p>Но согласитесь - выглядит не очень. Мы объявляем функцию sum, мы вынуждены передавать объявление функции в саму функцию при ее вызове, при сложении двух чисел мы работаем с тремя аргументами. Но это можно сделать более компактно и спрятать параметр sum от внешнего мира:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb8-1" title="1">(a b =&gt;</a>
<a class="sourceLine" id="cb8-2" title="2">    (sum a b =&gt; sum sum a b)</a>
<a class="sourceLine" id="cb8-3" title="3">    (sum a b =&gt;</a>
<a class="sourceLine" id="cb8-4" title="4">        <span class="kw">match</span> a</a>
<a class="sourceLine" id="cb8-5" title="5">        | O =&gt; b</a>
<a class="sourceLine" id="cb8-6" title="6">        | S a' =&gt; S (sum sum a' b)</a>
<a class="sourceLine" id="cb8-7" title="7">    )</a>
<a class="sourceLine" id="cb8-8" title="8">    a</a>
<a class="sourceLine" id="cb8-9" title="9">    b</a>
<a class="sourceLine" id="cb8-10" title="10">)</a></code></pre></div>
<p>Что здесь происходит? Объявляется функция у которой два параметра - a и b (складываемые числа), при этом телом функции является <code>apply</code> в котором функцией является еще одно объявление:</p>
<p><code>(sum a b =&gt; sum sum a b)</code>.</p>
<p>Это объявление - так называемая рекурсивная обвязка. В итоге у нас функция сложения смотрит в мир с нормальным интерфейсом на два параметра а сама рекурсивная обвязка спрятана в теле функции.</p>
<p>Вызов (3+2):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb9-1" title="1">(a b =&gt;</a>
<a class="sourceLine" id="cb9-2" title="2">  (sum a b =&gt; sum sum a b)</a>
<a class="sourceLine" id="cb9-3" title="3">    (sum a b =&gt;</a>
<a class="sourceLine" id="cb9-4" title="4">        <span class="kw">match</span> a</a>
<a class="sourceLine" id="cb9-5" title="5">        | O =&gt; b</a>
<a class="sourceLine" id="cb9-6" title="6">        | S a' =&gt; S (sum sum a' b)</a>
<a class="sourceLine" id="cb9-7" title="7">    )</a>
<a class="sourceLine" id="cb9-8" title="8">    a</a>
<a class="sourceLine" id="cb9-9" title="9">    b</a>
<a class="sourceLine" id="cb9-10" title="10">)</a>
<a class="sourceLine" id="cb9-11" title="11">(S (S (S O)))</a>
<a class="sourceLine" id="cb9-12" title="12">(S (S O))</a></code></pre></div>
<p>Если мы импортируем ее из модуля, то выглядит вообще почти как в нормальном языке программирования:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb10-1" title="1">(import sum from nat.tau)</a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3">sum (S (S (S O))) (S (S O))</a></code></pre></div>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
