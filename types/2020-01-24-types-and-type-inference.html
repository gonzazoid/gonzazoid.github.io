<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Gonzazoid's blog - Types and type inference</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Gonzazoid's blog</a>
            </div>
            <nav>
                <a href="../">Index</a>
                <a href="../resume_ru.html">[ Resume: RU</a>
                <a href="../resume.html">ENG ]</a>
                <a href="../contact.html">Contact</a>
            </nav>
        </header>

        <main role="main">
            <h1>Types and type inference</h1>
            <article>
    <section class="header">
        Posted on January 24, 2020
        
    </section>
    <section>
        <h3 id="section"></h3>
<blockquote>
So the writer who breeds more words than he needs, is making a chore for the reader who reads.
<footer>
—Dr. Seuss, <cite>We Can Do better</cite>
</footer>
</blockquote>
<p>Не буду вдаваться в подробности и определения типов данных - этой информации достаточно и в различных papers и на просторах интернетов, нет смысла повторяться. Для понимания нижеизложенного достаточно знать разницу между <a href="https://en.wikipedia.org/wiki/Structural_type_system">структурной</a> и <a href="https://en.wikipedia.org/wiki/Nominal_type_system">номинативной</a> типизациями.</p>
<p>Нижеизложенное является развитием идей структурной типизации.</p>
<p>Для того что бы понять идею достаточно рассмотреть одно определение типа и две функции. Тип описан в <code>Coq</code> нотации, функции даны в τ-lang нотации.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb1-1" title="1">Inductive nat : Type :=</a>
<a class="sourceLine" id="cb1-2" title="2">  | O</a>
<a class="sourceLine" id="cb1-3" title="3">  | S (n : nat).</a></code></pre></div>
<p>Тут не должно быть затруднений, мы описали индуктивно натуральные числа.</p>
<p>А теперь функция:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb2-1" title="1">(a =&gt; a)</a></code></pre></div>
<p>Должно быть понятно. Это <code>identity</code> функция. А теперь код который выражает саму суть размышлений:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb3-1" title="1">(a =&gt; </a>
<a class="sourceLine" id="cb3-2" title="2">  (num a =&gt; num num a)</a>
<a class="sourceLine" id="cb3-3" title="3">  (num a =&gt; <span class="kw">match</span> a</a>
<a class="sourceLine" id="cb3-4" title="4">    | O =&gt; O</a>
<a class="sourceLine" id="cb3-5" title="5">    | S a' =&gt; (S (num num a')) </a>
<a class="sourceLine" id="cb3-6" title="6">  )</a>
<a class="sourceLine" id="cb3-7" title="7">  a</a>
<a class="sourceLine" id="cb3-8" title="8">)</a></code></pre></div>
<p>Это тоже <code>identity</code> функция, но в отличие от первого варианта - не полиморфная. Она определена только на натуральных числах, любая другая структура (модель) вызовет ошибку на этой функции. Убедитесь пожалуйста в том что Вы понимаете как работает эта функция. Это важно. Если в понимании возникают затруднения - посмотрите пожалуйста <a href="../posts/2020-01-12-tau-core.html">описание τ-lang</a> и <a href="../posts/2020-01-10-tau-usage.html">практику применения</a>. Если и это не помогло - <a href="../contact.html">напишите мне</a>, постараюсь помочь.</p>
<p>Размышления над тем чем отличаются эти реализации <code>identity</code> приводят к интересным результатам.</p>
<p>В первую очередь, я полагаю, в глаза бросается схожесть ядра функции с определением типа. Речь об этом:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb4-1" title="1">(num a =&gt; <span class="kw">match</span> a</a>
<a class="sourceLine" id="cb4-2" title="2">  | O =&gt; O</a>
<a class="sourceLine" id="cb4-3" title="3">  | S a' =&gt; (S (num num a')) </a>
<a class="sourceLine" id="cb4-4" title="4">)</a></code></pre></div>
<p>сравните с определением типа:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb5-1" title="1">Inductive nat : Type :=</a>
<a class="sourceLine" id="cb5-2" title="2">  | O</a>
<a class="sourceLine" id="cb5-3" title="3">  | S (n : nat).</a></code></pre></div>
<p>Они не просто похожи, я настаиваю на том что это одно и тоже. Просто мы смотрим на один тот же процесс с разных сторон. С противоположных сторон.</p>
<p>Давайте разбираться. Начнем с типа.</p>
<p>О чем нам говорит объявление типа? Оно говорит нам что символ <code>O</code> принадлежит типу nat (является натуральным числом). Это выражено в первом клозе. А еще оно говорит нам что натуральное число может быть получено конструктором <code>S</code> которому в качестве параметра передано другое натуральное число. Ок. Какое натуральное число мы можем создать если никаких других натуральных чисел нет? Только <code>O</code>. А вот уже имея натуральное число мы можем применить второй клоз и получить <code>(S O)</code>, затем <code>(S (S O))</code> и так далее. То есть мы как бы берем терминатор (<code>O</code>) и начинаем наматывать на него возможные преобразования, получая на каждой итерации новое значение. В данном случае - процесс бесконечный, соотв. множество значений nat - бесконечное множество. Думаю тут не должно возникнуть проблем с пониманием, это то как работает индукция - есть базис и есть induction step(s).</p>
<p>Давайте теперь вглянем на функцию (только ядро, обвязка нам нужна только для объявления <code>fixpoint</code>). Приведу пример еще раз, что бы не приходилось скроллить:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb6-1" title="1">(num a =&gt; <span class="kw">match</span> a</a>
<a class="sourceLine" id="cb6-2" title="2">  | O =&gt; O</a>
<a class="sourceLine" id="cb6-3" title="3">  | S a' =&gt; (S (num num a')) </a>
<a class="sourceLine" id="cb6-4" title="4">)</a></code></pre></div>
<p>Мы получили на входе какое то число. Если это <code>O</code> то возвращаем <code>O</code> и выполнение завершается. Ок. Тут очевидно. Второй клоз интереснее. Если конструктор <code>S</code> - мы дублируем его в результате (справа от <code>=&gt;</code>). Кроме того, мы берем параметр конструктора и передаем его в обвязке <code>num num a'</code>. Если мы знаем что эта обвязка - <code>fixpoint</code> (а мы знаем это в этом конкретном случае, как это вычисляется - я выложу отдельной статьей) - то получается мы рекурсивно вызываем функцию с параметром конструктора <code>S</code>. То есть, если мы посмотрим на параметр <code>a'</code>, мы как бы разматываем клубок конструкторов, до тех пор пока не встретится <code>O</code>.</p>
<p>Надеюсь эта часть понятна. Основная мысль - индуктивное определение типа говорит нам как создавать значения этого типа - наматывание клубка. Рекурсивное определение функции <code>identity</code> на этом типе говорит нам как размотать значение этого типа. Можно <code>identity</code> воспринимать как фильтр, пропускающий только значения определенного типа, но об этом позже. Пока только наматывание и разматывание.</p>
<p>А давайте теперь с <code>identity</code> сделаем то же самое что мы сделали с определением типа. То есть посмотрим не на то как эта функция разматывает структуру данных, полученных на входе, а на то, какие именно данные эта функция может размотать. То есть возможно ли, глядя на описание этой функции вывести ее область определения? Оказывается да, возможно, как минимум для конкретно этой функции.</p>
<p>Глядя на клозы мы можем определить на каком условии эта функция завершится. Terminating case у нас в клозе <code>| O =&gt; O</code>. Этот клоз сработает если на входе будет символ (<code>CGT</code>) <code>O</code>. Мы это понимаем глядя на <strong>левую</strong> часть клоза. Отлично. Других завершающих клозов у нас нет, то есть ядро <em>клубка</em> у нас одно. Или, давайте уже переходить к нормальной терминологии, induction basis у нас равен единице. Ведь то что мы рассматриваем - это обычная структурная индукция.</p>
<p>Ок, идем дальше. Второй клоз - рекурсивный. Сам по себе он не завершится. Но он выйдет из рекурсии если <code>a'</code> (опять же <strong>слева</strong> от <code>=&gt;</code>) будет равно <code>O</code>. А это возможно если у нас на входе <code>(S O)</code>. Мы можем это понять глядя на <code>pattern matching</code> клоза. То есть мы понимаем что вторым возможным значением из области определения <code>identity</code> будет <code>(S O)</code>. Почему? Потому что <code>pattern matching</code> этого клоза умеет разматывать только <code>S</code> конструкторы. То есть по левой части клоза мы можем восстановить индуктивное определение типа структуры с которой этот клоз может работать.</p>
<p>Что дальше? А дальше просто - других клозов у нас нет, условие выхода рекурсивного клоза в терминальный мы отработали, остается только понять, как еще мы можем попасть в рекурсивный клоз. А попасть в него мы можем если на входе будет бОльшая структура. Например <code>(S (S O))</code>. Как мы можем это понять? Так же, как мы вывели <code>(S O)</code> - находясь в рекурсивном клозе и глядя на его <code>pattern matching</code>.</p>
<p>То есть что произошло? Мы вывели тип данных области определения функции <code>identity</code>. Это будет тип:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb7-1" title="1">nat = O | (S  nat)</a></code></pre></div>
<p>Ровно та информация, что заключена в описании типа <code>nat</code> в Coq нотации.</p>
<p>Все это достаточно очевидные вещи. То есть что мы сделали? Мы просто извлекли информацию о типе данных (а точнее - его индуктивное определение) из описания функции. Но тут интересный момент. Если мы можем вывести область определения функции - мы знаем то множество значений на которых эта функция <strong>завершится</strong>. И класс функций, для которых область значений выводима, довольно немаленький. То есть есть какое то множество функций для которых мы в состоянии решить halting problem.</p>
<p>Подведу промежуточный итог:</p>
<ul>
<li>Тип - это информация о структуре данных. В номинативных системах типов (например <a href="https://en.wikipedia.org/wiki/Calculus_of_constructions">Calculus of constructions</a>, <a href="https://coq.inria.fr/refman/language/cic.html">Calculus of Inductive Constructions</a>, <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley–Milner type system</a> ) тип является просто меткой, тегом, каким то названием. Сама информация о структуре данных, соответствующих этому типу - в выводе типов не используется. В τ-lang можно реализовать структурную типизацию и использовать эту информацию в выводе типов.</li>
<li>есть множество функций для которых мы можем вывести область определения через структурную индукцию</li>
<li>знание области определения функции равносильно решению halting problem для этой фунции.</li>
</ul>
<p>Давайте продолжим.</p>
<p>У нас есть некоторое множество функций для которых мы можем выводить тип области определения. Пока не углубляемся в то какое именно это множество, достаточно того что оно непустое.</p>
<p>А можем ли мы так же выводить тип области значений? Оказывается что да, можем. Причем размышления и техника исполнения абсолютно та же что при выводе типа области определения, но смотреть мы будем на правые части клозов. Давайте пройдемся.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb8-1" title="1">  (num a =&gt; <span class="kw">match</span> a</a>
<a class="sourceLine" id="cb8-2" title="2">    | O =&gt; O</a>
<a class="sourceLine" id="cb8-3" title="3">    | S a' =&gt; (S (num num a')) </a>
<a class="sourceLine" id="cb8-4" title="4">  )</a></code></pre></div>
<p>По первому клозу мы видим что функция завершится с возвратом значения O. В этот раз мы не думаем о том в каком случае это произойдет, мы думаем о том что если это произойдет то вернется O. То есть это одно из возможных значений области значений функции. Глядя на второй клоз привычно отмечаем что это fixpoint и смотрим на правую часть клоза. В правой части мы видим что применяется конструктор S к чему? правильно, к какому то значению которое возвращает рекурсивный вызов. То есть к значению из области значений. А оно у нас там пока одно. То есть (S O) это еще одно возможное значение из области значений функции. Поскольку других клозов нет, а второй клоз - fixpoint, мы понимаем что множество других значений может быть построено применением индуктивного шага (S nat). То есть тот же самый ход размышлений что и при выводе типа области определения, что не удивительно - мы то рассматриваем функцию identity. На других функциях построение типа конечно может отличаться.</p>
<p>Хорошо. Мы можем (конкретно для этой функции) выводить тип области определения и области значений. То есть по сути мы вывели тип самой функции - <code>nat -&gt; nat</code>.</p>
<p>Давайте теперь познакомимся с RealWorld. Помните, <a href="https://hoogle.haskell.org/?hoogle=RealWorld">тот самый</a> из haskell:</p>
<blockquote>
<p>RealWorld is deeply magical. It is primitive, but it is not unlifted (hence ptrArg). We never manipulate values of type RealWorld; it’s only used in the type system, to parameterise State#.</p>
</blockquote>
<p>У нас в τ-lang тоже есть такой, но он парень простой, без пафоса. Это символ <code>*</code>. Про него будет отдельная статья с подробностями, пока что достаточно знать одно его свойство - он является множеством всех возможных значений. То есть он содержит вообще все что мы можем смоделировать. Ок.</p>
<p>А теперь, прежде чем продолжить, напомню одно свойство τ-lang - если на вход <code>match</code> функции (FDEF, не FCOMP) попадает структура с конструктором для которого нет подходящего <code>pattern</code> - исполнение кода аварийно завершается. В τ-lang нет исключений, обработки ошибок такого рода. Позже мы это все смоделируем в стейт-машинах, но в самом интерпретаторе этого нет. Вместо этого мы считаем что данная функция не определена на этом значении.</p>
<p>А теперь с двумя этими хинтами в голове давайте снова взглянем на нашу функцию identity:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb9-1" title="1">(a =&gt; </a>
<a class="sourceLine" id="cb9-2" title="2">  (num a =&gt; num num a)</a>
<a class="sourceLine" id="cb9-3" title="3">  (num a =&gt; <span class="kw">match</span> a</a>
<a class="sourceLine" id="cb9-4" title="4">    | O =&gt; O</a>
<a class="sourceLine" id="cb9-5" title="5">    | S a' =&gt; (S (num num a')) </a>
<a class="sourceLine" id="cb9-6" title="6">  )</a>
<a class="sourceLine" id="cb9-7" title="7">  a</a>
<a class="sourceLine" id="cb9-8" title="8">) *</a></code></pre></div>
<p>Это apply который не будет выполняться - по той простой причине что у нас нет значения аргумента. Вместо этого мы говорим что на входе может быть любое возможное значение. Ок. При этом мы знаем что можно вывести тип значений на выходе (тип области значений). А тип области определения мы вывели ранее. Значит мы можем размышлять следующим образом:</p>
<p>Что бы мы ни подали на входе этой функции (*):</p>
<ul>
<li>либо ее исполнение завершится аварийно (модель на входе будет не nat)</li>
<li>либо модель на входе - nat и тогда результат - тоже nat</li>
</ul>
<p>Мы можем перефразировать это умозаключение - результатом выполнения этой функции всегда будет nat (потому что если функция выполнилась - она вернула nat, ничего другого она вернуть не может)</p>
<p>Это подводит нас к простой мысли:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode ml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb10-1" title="1">(a =&gt; </a>
<a class="sourceLine" id="cb10-2" title="2">  (num a =&gt; num num a)</a>
<a class="sourceLine" id="cb10-3" title="3">  (num a =&gt; <span class="kw">match</span> a</a>
<a class="sourceLine" id="cb10-4" title="4">    | O =&gt; O</a>
<a class="sourceLine" id="cb10-5" title="5">    | S a' =&gt; (S (num num a')) </a>
<a class="sourceLine" id="cb10-6" title="6">  )</a>
<a class="sourceLine" id="cb10-7" title="7">  a</a>
<a class="sourceLine" id="cb10-8" title="8">) *</a></code></pre></div>
<p>является объявлением типа nat. Это частное заключение. Более общее: любая структурная identity функция (при условии что мы можем вывести ее тип) является объявлением типа. То есть во первых нам не нужен специальный синтаксис для типов (что вобщем то не так существенно но приятно) а во вторых, и это важный момент - поскольку функция несет в себе информацию как о типе области определения так и о типе области значений - она может рассматриваться как объявление типа.</p>
<p>И это действительно важный момент с которым мы будем неоднократно сталкиваться.</p>
<p>На этом пока все, в дальнейшем поговорим о том на каких функциях мы можем делать вывод типов а на каких нет, обсудим регулярные типы и то как они расширяют зависимые типы.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
